# rdt3.0의 문제점
rdt 3.0은 전송-후-대기(stop-and-wait)프로토콜을 사용한다.    
문제는 RTT동안 아무것도 하지 않으므로 utilization이 떨어진다.그럼 어떻게 utilization을 올릴까??      
utilization= ( L/R ) / ( RTT + L/R )        
utilization=  ( N*L/R ) / ( RTT + L/R ) 이렇게 같은 시간 동안 패킷을 더 보내주면 해결 가능하다. 이 방식을 파이프라이닝이라고 한다.    

### GO BACK N (GBN) 
1. GBN프로토콜에서는 송신자는 확인응답을 기다리지 않고 여러 패킷을 전송할 수 있다.그러나 파이프라인에서 확인응답이 안된 패킷의 최대 허용 수 N보다 크지 않아야 한다.         
2. N은 **윈도우 사이즈**이다.GBN은 **슬라이딩 윈도우 프로토콜**라고 한다.    
3. 만약 수신자가 잘못된 순서의 패킷을 받는다면 수신자는 가장 최근에 전송된 시퀀스번호를 ACK에 담아서 보낸다.      
   이를 받은 송신자는 **내가 전에 보낸 패킷중 누락된 패킷이 존재하는구나! 그럼 윈도우에 들어있는 모든 패킷을 다 다시 보내야겠다**이렇게 생각하고        
   모든 패킷을 전부 보낸다.즉 [0,1,2,3] 이 현재 윈도우 범위라면 [0,1,2,3]을 모두 다 보낸다. 이렇게 N만큼 돌아가서 GO BACK N이다.       
   송신자가 Time Out이 발생해도 N만큼 다시 전송한다.      
4. 수신자는 바보같다.     
5. 수신자가 보내는 ACK는 올바른 순서로 받은 마지막 패킷이다.     
6. GBN에서 수신자는 버퍼가 없어서 잘못된 순서의 패킷을 그냥 폐기한다.       
7. 만약 올바른 순서로 전송된 패킷이면 애플리케이션 계층에 전달한다.     

### Selective Request (SR)  
1. GBN에서 송신자가 N개의 패킷을 재전송 하기 때문에 파이프라인이 가득찬다, 때문에 전송 속도가 느려진다.     
2. 그래서 나온것이 SR이다.       
3. SR은 오류가 발생한 패킷만 재전송한다. [0,1,2,3]에서 2번만 오류가 발생시 , 2번 패킷만 재전송한다.         
4. 송신자는 ACK가 전송되면 가장 앞의 ACK인 경우 윈도우를 전진시킨다. 만약 그게 아니라면 수신완료 표시만 하고, 
    나머지 패킷들이 정장적으로 보내진걸 알게된 후 윈도우를 N만큼 전진한다 .       
6. 수신자 ACK는 수신자가 받은 패킷 번호이다.    
7. 수신자에는 버퍼가 존재한다.    
8. 수신자는 가장 앞의  패킷이 전송된 경우 바로 애플리케이션 계층으로 전송한다.그리고 윈도우는 전진한다. 
9. 만약 수신자가 받은 패킷이 윈도우에서 가장 앞의 패킷이 아니라면 
   버퍼에 저장하고 윈도우를 전진시키지 않는다.그리고 누락된 패킷을 모두 전송받았다면 애플리케이션 계층으로 버퍼에 있는 정보를 전달한다.         

